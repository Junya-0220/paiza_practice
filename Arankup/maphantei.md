# マップの判定・縦横

## Step1 盤面情報の取得

行数 H , 列数 W の盤面があり、各マスには文字が 1 つだけ書かれています。
盤面と N 個の y , x 座標 が与えられるので、与えられた座標の文字を順に出力してください。

なお、マスの座標系は左上端のマスの座標を ( y , x ) = ( 0 , 0 ) とし、
下方向が y 座標の正の向き、右方向が x 座標の正の向きとします

### 方針

まず入力を受け取り盤面を表す二重配列をつくります。
その後ループで n 個の座標を受け取り盤面の配列のインデックスを指定して出力します。


```Go
func Step1() {
	var H, W, N int
	fmt.Scan(&H, &W, &N)

	S := make([][]rune, H)
	for i := 0; i < H; i++ {
		S[i] = make([]rune, W)
		var line string
		fmt.Scan(&line)
		for j, char := range line {
			S[i][j] = char
		}
	}

	for i := 0; i < N; i++ {
		var y, x int
		fmt.Scan(&y, &x)
		fmt.Println(string(S[y][x]))
	}
}
```


## Step2 盤面情報の変更

行数 H , 列数 W の盤面があり、各マスには文字が 1 つだけ書かれています。盤面と N 個 の y , x 座標 が与えられるので、盤面の与えられた座標の文字を "#" に書き換えた後の盤面を出力してください。

なお、マスの座標系は左上端のマスの座標を ( y , x ) = ( 0 , 0 ) とし、
下方向が y 座標の正の向き、右方向が x 座標の正の向きとします。

### 方針

マップは文字列の配列として受け取ると良いです。
マップの i 行 j 列の要素は、 S[i][j] で受け取れます。
S[i][j]='#' とすることで要素を書き換えられます。

```Go
func Step2() {
	var h, w, n int
	fmt.Scan(&h, &w, &n)

	s := make([][]rune, h)
	for i := 0; i < h; i++ {
		s[i] = make([]rune, w)
		var line string
		fmt.Scan(&line)
		for j, char := range line {
			s[i][j] = char
		}
	}

	for i := 0; i < n; i++ {
		var y, x int
		fmt.Scan(&y, &x)
		s[y][x] = '#'
	}

	for y := 0; y < h; y++ {
		fmt.Println(string(s[y]))
	}
}

```


## Step3 マップの判定・横

行数 H , 列数 W の盤面があり、盤面の各マスには文字が 1 つだけ書かれています。
盤面が与えられるので、「左右のマスが "#" 」であるようなマスの座標を全て出力してください。

ただし、左端のマスの場合は「右のマスが "#" 」であれば、右端のマスの場合は「左のマスが "#" 」であれば条件を満たすものとします。

なお、マスの座標系は左上端のマスの座標を ( y , x ) = ( 0 , 0 ) とし、
下方向が y 座標の正の向き、右方向が x 座標の正の向きとします。

### 方針

マップのj行i列のマスの左右の要素は、それぞれ S[i][j-1], S[i][j+1] で受け取れます。
左右の端のマスの時は、左右のマスは条件を満たすとするか、例外的に処理して判定すると良いです。

1つ目のif文で注目しているマスの左側のマスについて判定しています。 注目しているマスが左端のとき、もしくは "#" のとき条件を満たしていると判定しています。
このとき、 s[y][x - 1] == "#" or x == 0 とすると IndexError と、範囲外参照が起こるため解答コードのように記述しています。
1つ目のif文で注目しているマスの右側のマスについて判定しています。 注目しているマスが右端のとき、もしくは "#" のとき条件を満たしていると判定しています。
このとき、 s[y][x + 1] == "#" or x == w - 1 とすると範囲外参照が起こるため解答コードのように記述しています。

```Go
func Step3() {
	var h, w int
	fmt.Scan(&h, &w)

	s := make([][]rune, h)
	for i := 0; i < h; i++ {
		s[i] = make([]rune, w)
		var line string
		fmt.Scan(&line)
		for j, char := range line {
			s[i][j] = char
		}
	}

	for y := 0; y < h; y++ {
		for x := 0; x < w; x++ {
			if x == 0 || s[y][x-1] == '#' {
				if x == w-1 || s[y][x+1] == '#' {
					fmt.Println(y, x)
				}
			}
		}
	}
}

```


## Step4 マップの判定・縦

マップの行数 H と列数 W とマップを表す H 行 W 列の文字列 S_1 ... S_H が与えられるので、
上下のマスがどちらも '#' であるようなマスの y , x 座標 を答えてください。

ただし、上端のマスの場合は「下のマスが '#'」であれば、下端のマスの場合は「上のマスが '#'」であれば条件を満たすものとします。

なお、マスの座標系は左上端のマスの座標を ( y , x ) = ( 0 , 0 ) とし、
下方向が y 座標の正の向き、右方向が x 座標の正の向きとします。

### 方針

マップのj行i列のマスの上下の要素は、それぞれ S[i-1][j], S[i+1][j] で受け取れます。
上下の端のマスの時は、上下のマスは条件を満たすとするか、例外的に処理して判定します。


二重ループを使いすべてのマスを確認します。
1つ目のif文で注目しているマスの上側のマスについて判定し、2つめのif文で注目しているマスの下側のマスについて判定しています。
このとき、範囲外参照を防ぐため上端、下端を先に判定するように記述しています

```Go
func Step4() {
	var h, w int
	fmt.Scan(&h, &w)

	s := make([][]rune, h)
	for i := 0; i < h; i++ {
		s[i] = make([]rune, w)
		var line string
		fmt.Scan(&line)
		for j, char := range line {
			s[i][j] = char
		}
	}

	for y := 0; y < h; y++ {
		for x := 0; x < w; x++ {
			if y == 0 || s[y-1][x] == '#' {
				if y == h-1 || s[y+1][x] == '#' {
					fmt.Println(y, x)
				}
			}
		}
	}
}
```


## Step5 マップの判定・縦横

マップの行数 H と列数 W とマップを表す H 行 W 列の文字列 S_1 ... S_H が与えられるので、
隣接する上下左右のマスが全て '#' であるマスの y , x 座標 を答えてください。

ただし、左端のマスの場合は「右のマスが '#' 」であれば、右端のマスの場合は「左のマスが '#' 」であれば隣接する左右のマスが全て '#' であるものとします。
また、上端のマスの場合は「下のマスが '#' 」であれば、下端のマスの場合は「上のマスが '#' 」であれば隣接する上下のマスが全て "#" であるものとします。

なお、マスの座標系は左上端のマスの座標を ( y , x ) = ( 0 , 0 ) とし、
下方向が y 座標の正の向き、右方向が x 座標の正の向きとします。

### 方針

マップの j 行 i 列のマスに隣接している要素は、それぞれ S[i][j-1], S[i][j+1], S[i-1][j], S[i+1][j] で受け取れます。
上下左右の端のマスの時は、マップ外に当たるマスは条件を満たすとするか、例外的に処理して判定します。

二重ループを使いすべてのマスを確認します。
左右のマスが"#"であるかを flag_row 、上下のマスが"#"であるかを flag_column で管理します。
flag_row and flag_column が True のときマスの座標を出力しています。

```Go
func Step5() {
	var h, w int
	fmt.Scan(&h, &w)

	s := make([][]rune, h)
	for i := 0; i < h; i++ {
		s[i] = make([]rune, w)
		var line string
		fmt.Scan(&line)
		for j, char := range line {
			s[i][j] = char
		}
	}

	for y := 0; y < h; y++ {
		for x := 0; x < w; x++ {
			flagRow := false
			flagColumn := false

			if x == 0 || s[y][x-1] == '#' {
				if x == w-1 || s[y][x+1] == '#' {
					flagRow = true
				}
			}

			if y == 0 || s[y-1][x] == '#' {
				if y == h-1 || s[y+1][x] == '#' {
					flagColumn = true
				}
			}

			if flagColumn && flagRow {
				fmt.Println(y, x)
			}
		}
	}
}

```